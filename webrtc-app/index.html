<!DOCTYPE html> 
<html>
  <head>
    <title>WebRTC Example</title>
    <link rel="stylesheet" href="css/index.css">
  </head>
  <body>
    <h1>WebRTC Example</h1>
    <div id="error" class="error-message"></div>
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>
    <script>

      const localVideo = document.getElementById('localVideo');
      const remoteVideo = document.getElementById('remoteVideo');
      const errorMessageDiv = document.getElementById('error');

      let streamPromise;
      let localStream;
      let localPeerConnection, remotePeerConnection;

      streamPromise = navigator.mediaDevices.getUserMedia({ 
        video: true,
        audio: true 
      })
      .then(stream => {
        localVideo.srcObject = stream;
        localStream = stream;
      })
      .catch((error) => {
        const errorMessage = 
          (error.name == 'NotAllowedError') ? 
          'Permission denied. Please allow access to camera and microphone' : 
          `Error accessing media devices: ${error.message}`
        errorMessageDiv.textContent = errorMessage;
        console.log(error.name)
        console.log(error.message)
      })

      function createPeerConnection(source){
        const peerConnection = new RTCPeerConnection()

        // handle ICE candidate
        peerConnection.onicecandidate = event => {
          if (event.candidate) {
            ws.send(JSON.stringify({ source, candidate: event.candidate }));
          } else {
            console.log(`All ICE candidates from ${source} are sent`)
          }
        };

        // handle tracks
        peerConnection.ontrack = event => {
          remoteVideo.srcObject = event.streams[0];
        };

        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        return peerConnection
      }

      const ws = new WebSocket('ws://localhost:8080');
      
      ws.onmessage = async (message) => {
        const data = JSON.parse(message.data);
        if (data.offer) {
          console.log('Handle offer:', data.offer)
          remotePeerConnection = createPeerConnection('remote')
          await remotePeerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await remotePeerConnection.createAnswer();
          await remotePeerConnection.setLocalDescription(answer);
          ws.send(JSON.stringify({ answer }));
        }
        if (data.answer) {
          console.log('Handle answer by local:', data.answer)
          await localPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        if (data.candidate) {
          const source = data.source;
          if (source == 'local'){
            console.log('ICE candidate from local. Set candidate for remote peer connection...')
            console.log('remotePeerConnection:', remotePeerConnection)
            await remotePeerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          } else {
            console.log('ICE candidate from remote. Set candidate for local peer connection...')
            console.log('localPeerConnection:', localPeerConnection)
            await localPeerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        }
      };
      
      ws.onopen = async () => {
        // wait for local stream to be available before creating offer
        await streamPromise;
        createOffer();
      };

      ws.onclose = () => {
        console.log('WebSocket connection closed');
      };

      async function createOffer() {
        localPeerConnection = createPeerConnection('local')
        const offer = await localPeerConnection.createOffer();
        await localPeerConnection.setLocalDescription(offer);
        ws.send(JSON.stringify({ offer }));
      }

    </script>
  </body>
</html>